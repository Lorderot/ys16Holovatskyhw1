# ys16Holovatskyhw1
ConcurrencyHomeWork

1. Написать программу, подсчитывающую в M потоках сумму ряда sin(x)*cos(x), где x пробегает диапазон от -N до N, с шагом step = 0.0001
//sum = sin(-N)*cos(-N) + …  + sin(N)*cos(N)//
    a) При реализации не использовать блоки синхронизации и библиотеку java.util.concurrent - //(package ua.yandex.sumofseries.threads)//
    b) При реализации использовать ExecutorService, и интерфейс Callable из библиотеки java.util.concurrent - //(package ua.yandex.sumofseries.utilconcurrent)//
Провести тестирование и определить, в скольких потоках оптимальнее считать сумму ряда (зависимость времени подсчета от числа потоков). 

2. Реализовать параллельную версию алгоритма сортировки слиянием (mergesort), в соответствии с алгоритмом, приведенным в  разделе ((https://mitpress.mit.edu/sites/default/files/titles/content/9780262033848_sch_0001.pdf 27.3 Multithreaded merge sort)) - //(package ua.yandex.mergesort)//

3. На основании шаблона ((http://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html Producer/Consumer)) реализовать блокирующий ((http://en.wikipedia.org/wiki/Circular_buffer кольцевой буфер)) на N элементов.  Если буфер пуст, то читающие потоки должны ждать появления в нем элементов. Если буфер заполнен, то пишущие потоки должны ждать удаление элементов.
  a) При реализации не использовать библиотеку java.util.concurrent - //(package ua.yandex.prodcons.threads)//
  b) При реализации использовать ReentrantLock и Condition из библиотеки java.util.concurrent - //(package ua.yandex.prodcons.utilconcurrent)//

4. Реализуйте пул потоков для фиксированного числа поток (количество потоков в пуле задается в конструкторе пула). Проведите его тестирование с учетом того, что заданий может быть больше чем число свободных потоков. Описание ((http://en.wikipedia.org/wiki/Thread_pool_pattern Thread pool pattern)). При реализации не использовать библиотеку java.util.concurrent - //(package ua.yandex.threadpool)//

5. Напишите lock-free реализацию класса с методом BigInteger next(), который возвращает элементы последовательности: [1, 2, 4, 8, 16, ...]. Код должен корректно работать в многопоточной среде. Протестируйте на предмет отсутствия пропусков и дубликатов - //(package ua.yandex.lockfree)// 

6. У Вас имеется массив слов (строк) - words. Используя подход Fork/Join напишите реализацию WordCount подсчитывающую сколько раз каждое слов встречается в массиве (package ua.yandex.fj). В результате у вас должна быть Map<String, Integer> wordsCount. При реализации используйте ForkJoin Pool

7. У Вас есть класс Bank с методом transfer() для перевода денег с одного счета на другой в пределах банка - //(package ua.yandex.bank)//
public class Bank{
  public void transfer(Account from, Account to,int amount){
    atomic{
      from.withdraw(amount);
      to.deposit(amount);
    }
  }
}

К сожалению, в Java отсутствует конструкция типа atomic для выполнения транзакций. 
Напишите свою реализация тела метода transfer(), которая могла бы работать в многопоточной среде (не используя синхронизацию на экземпляре класса Bank и не блокируя транзакций с другими счетами).
Во время перевода денег со счета на счет, данные счета должны блокироваться. Подумайте, как при этом избежать deadlock-ов.
Выполните тестирование метода transfer(). Для этого: 
  1) Создайте несколько десятков (сотен) счетов и положите на них случайное количество денег
  2) Подсчитайте сколько денег есть всего в банке (сумма денег на всех счетах)
  3) Запустите в нескольких тысячах потоков одновременные перевод случайных сумм денег со случайного счета на случайный счет (сумма на счету не может быть отрицательной)
  4) Дождитесь окончания перевод и подсчитайте сколько денег есть всего в банке (сумма денег на всех счетах). Сумма денег в банке до переводов и после, должны совпадать.
